# -*- coding: utf-8 -*-
""" Test printing of scalar types.

"""
from __future__ import division, absolute_import, print_function

import code, sys
import platform
import pytest

from tempfile import TemporaryFile
import numpy as np
from numpy.testing import assert_, assert_equal, suppress_warnings

class TestRealScalars(object):
    def test_str(self):
        svals = [0.0, -0.0, 1, -1, np.inf, -np.inf, np.nan]
        styps = [np.float16, np.float32, np.float64, np.longdouble]
        wanted = [
             ['0.0',  '0.0',  '0.0',  '0.0' ],
             ['-0.0', '-0.0', '-0.0', '-0.0'],
             ['1.0',  '1.0',  '1.0',  '1.0' ],
             ['-1.0', '-1.0', '-1.0', '-1.0'],
             ['inf',  'inf',  'inf',  'inf' ],
             ['-inf', '-inf', '-inf', '-inf'],
             ['nan',  'nan',  'nan',  'nan']]

        for wants, val in zip(wanted, svals):
            for want, styp in zip(wants, styps):
                msg = 'for str({}({}))'.format(np.dtype(styp).name, repr(val))
                assert_equal(str(styp(val)), want, err_msg=msg)

    def test_scalar_cutoffs(self):
        # test that both the str and repr of np.float64 behaves
        # like python floats in python3. Note that in python2
        # the str has truncated digits, but we do not do this
        def check(v):
            # we compare str to repr, to avoid python2 truncation behavior
            assert_equal(str(np.float64(v)), repr(v))
            assert_equal(repr(np.float64(v)), repr(v))

        # check we use the same number of significant digits
        check(1.12345678901234567890)
        check(0.0112345678901234567890)

        # check switch from scientific output to positional and back
        check(1e-5)
        check(1e-4)
        check(1e15)
        check(1e16)

    def test_py2_float_print(self):
        # gh-10753
        # In python2, the python float type implements an obsolete method
        # tp_print, which overrides tp_repr and tp_str when using "print" to
        # output to a "real file" (ie, not a StringIO). Make sure we don't
        # inherit it.
        x = np.double(0.1999999999999)
        with TemporaryFile('r+t') as f:
            print(x, file=f)
            f.seek(0)
            output = f.read()
        assert_equal(output, str(x) + '\n')
        # In python2 the value float('0.1999999999999') prints with reduced
        # precision as '0.2', but we want numpy's np.double('0.1999999999999')
        # to print the unique value, '0.1999999999999'.

        # gh-11031
        # Only in the python2 interactive shell and when stdout is a "real"
        # file, the output of the last command is printed to stdout without
        # Py_PRINT_RAW (unlike the print statement) so `>>> x` and `>>> print
        # x` are potentially different. Make sure they are the same. The only
        # way I found to get prompt-like output is using an actual prompt from
        # the 'code' module. Again, must use tempfile to get a "real" file.

        # dummy user-input which enters one line and then ctrl-Ds.
        def userinput():
            yield 'np.sqrt(2)'
            raise EOFError
        gen = userinput()
        input_func = lambda prompt="": next(gen)

        with TemporaryFile('r+t') as fo, TemporaryFile('r+t') as fe:
            orig_stdout, orig_stderr = sys.stdout, sys.stderr
            sys.stdout, sys.stderr = fo, fe

            # py2 code.interact sends irrelevant internal DeprecationWarnings
            with suppress_warnings() as sup:
                sup.filter(DeprecationWarning)
                code.interact(local={'np': np}, readfunc=input_func, banner='')

            sys.stdout, sys.stderr = orig_stdout, orig_stderr

            fo.seek(0)
            capture = fo.read().strip()

        assert_equal(capture, repr(np.sqrt(2)))

    def test_dragon4(self):
        # these tests are adapted from Ryan Juckett's dragon4 implementation,
        # see dragon4.c for details.

        fpos32 = lambda x, **k: np.format_float_positional(np.float32(x), **k)
        fsci32 = lambda x, **k: np.format_float_scientific(np.float32(x), **k)
        fpos64 = lambda x, **k: np.format_float_positional(np.float64(x), **k)
        fsci64 = lambda x, **k: np.format_float_scientific(np.float64(x), **k)

        preckwd = lambda prec: {'unique': False, 'precision': prec}

        assert_equal(fpos32('1.0'), "1.")
        assert_equal(fsci32('1.0'), "1.e+00")
        assert_equal(fpos32('10.234'), "10.234")
        assert_equal(fpos32('-10.234'), "-10.234")
        assert_equal(fsci32('10.234'), "1.0234e+01")
        assert_equal(fsci32('-10.234'), "-1.0234e+01")
        assert_equal(fpos32('1000.0'), "1000.")
        assert_equal(fpos32('1.0', precision=0), "1.")
        assert_equal(fsci32('1.0', precision=0), "1.e+00")
        assert_equal(fpos32('10.234', precision=0), "10.")
        assert_equal(fpos32('-10.234', precision=0), "-10.")
        assert_equal(fsci32('10.234', precision=0), "1.e+01")
        assert_equal(fsci32('-10.234', precision=0), "-1.e+01")
        assert_equal(fpos32('10.234', precision=2), "10.23")
        assert_equal(fsci32('-10.234', precision=2), "-1.02e+01")
        assert_equal(fsci64('9.9999999999999995e-08', **preckwd(16)),
                            '9.9999999999999995e-08')
        assert_equal(fsci64('9.8813129168249309e-324', **preckwd(16)),
                            '9.8813129168249309e-324')
        assert_equal(fsci64('9.9999999999999694e-311', **preckwd(16)),
                            '9.9999999999999694e-311')


        # test rounding
        # 3.1415927410 is closest float32 to np.pi
        assert_equal(fpos32('3.14159265358979323846', **preckwd(10)),
                            "3.1415927410")
        assert_equal(fsci32('3.14159265358979323846', **preckwd(10)),
                            "3.1415927410e+00")
        assert_equal(fpos64('3.14159265358979323846', **preckwd(10)),
                            "3.1415926536")
        assert_equal(fsci64('3.14159265358979323846', **preckwd(10)),
                            "3.1415926536e+00")
        # 299792448 is closest float32 to 299792458
        assert_equal(fpos32('299792458.0', **preckwd(5)), "299792448.00000")
        assert_equal(fsci32('299792458.0', **preckwd(5)), "2.99792e+08")
        assert_equal(fpos64('299792458.0', **preckwd(5)), "299792458.00000")
        assert_equal(fsci64('299792458.0', **preckwd(5)), "2.99792e+08")

        assert_equal(fpos32('3.14159265358979323846', **preckwd(25)),
                            "3.1415927410125732421875000")
        assert_equal(fpos64('3.14159265358979323846', **preckwd(50)),
                         "3.14159265358979311599796346854418516159057617187500")
        assert_equal(fpos64('3.14159265358979323846'), "3.141592653589793")


        # smallest numbers
        assert_equal(fpos32(0.5**(126 + 23), unique=False, precision=149),
                    "0.00000000000000000000000000000000000000000000140129846432"
                    "4817070923729583289916131280261941876515771757068283889791"
                    "08268586060148663818836212158203125")
        assert_equal(fpos64(0.5**(1022 + 52), unique=False, precision=1074),
                    "0.00000000000000000000000000000000000000000000000000000000"
                    "0000000000000000000000000000000000000000000000000000000000"
                    "0000000000000000000000000000000000000000000000000000000000"
                    "0000000000000000000000000000000000000000000000000000000000"
                    "0000000000000000000000000000000000000000000000000000000000"
                    "0000000000000000000000000000000000049406564584124654417656"
                    "8792868221372365059802614324764425585682500675507270208751"
                    "8652998363616359923797965646954457177309266567103559397963"
                    "9877479601078187812630071319031140452784581716784898210368"
                    "8718636056998730723050006387409153564984387312473397273169"
                    "6151400317153853980741262385655911710266585566867681870395"
                    "6031062493194527159149245532930545654440112748012970999954"
          sCode":403},
      "exception":true
    },
    "AdditionalAuthenticationProvider":{
      "type":"structure",
      "members":{
        "authenticationType":{
          "shape":"AuthenticationType",
          "documentation":"<p>The authentication type: API key, AWS IAM, OIDC, or Amazon Cognito user pools.</p>"
        },
        "openIDConnectConfig":{
          "shape":"OpenIDConnectConfig",
          "documentation":"<p>The OpenID Connect configuration.</p>"
        },
        "userPoolConfig":{
          "shape":"CognitoUserPoolConfig",
          "documentation":"<p>The Amazon Cognito user pool configuration.</p>"
        }
      },
      "documentation":"<p>Describes an additional authentication provider.</p>"
    },
    "AdditionalAuthenticationProviders":{
      "type":"list",
      "member":{"shape":"AdditionalAuthenticationProvider"}
    },
    "ApiCache":{
      "type":"structure",
      "members":{
        "ttl":{
          "shape":"Long",
          "documentation":"<p>TTL in seconds for cache entries.</p> <p>Valid values are between 1 and 3600 seconds.</p>"
        },
        "apiCachingBehavior":{
          "shape":"ApiCachingBehavior",
          "documentation":"<p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resovlers that you specify are cached.</p> </li> </ul>"
        },
        "transitEncryptionEnabled":{
          "shape":"Boolean",
          "documentation":"<p>Transit encryption flag when connecting to cache. This setting cannot be updated after creation.</p>"
        },
        "atRestEncryptionEnabled":{
          "shape":"Boolean",
          "documentation":"<p>At rest encryption flag for cache. This setting cannot be updated after creation.</p>"
        },
        "type":{
          "shape":"ApiCacheType",
          "documentation":"<p>The cache instance type.</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>"
        },
        "status":{
          "shape":"ApiCacheStatus",
          "documentation":"<p>The cache instance status.</p> <ul> <li> <p> <b>AVAILABLE</b>: The instance is available for use.</p> </li> <li> <p> <b>CREATING</b>: The instance is currently creating.</p> </li> <li> <p> <b>DELETING</b>: The instance is currently deleting.</p> </li> <li> <p> <b>MODIFYING</b>: The instance is currently modifying.</p> </li> <li> <p> <b>FAILED</b>: The instance has failed creation.</p> </li> </ul>"
        }
      }
    },
    "ApiCacheStatus":{
      "type":"string",
      "enum":[
        "AVAILABLE",
        "CREATING",
        "DELETING",
        "MODIFYING",
        "FAILED"
      ]
    },
    "ApiCacheType":{
      "type":"string",
      "enum":[
        "T2_SMALL",
        "T2_MEDIUM",
        "R4_LARGE",
        "R4_XLARGE",
        "R4_2XLARGE",
        "R4_4XLARGE",
        "R4_8XLARGE"
      ]
    },
    "ApiCachingBehavior":{
      "type":"string",
      "enum":[
        "FULL_REQUEST_CACHING",
        "PER_RESOLVER_CACHING"
      ]
    },
    "ApiKey":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The API key ID.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>A description of the purpose of the API key.</p>"
        },
        "expires":{
          "shape":"Long",
          "documentation":"<p>The time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour.</p>"
        }
      },
      "documentation":"<p>Describes an API key.</p> <p>Customers invoke AWS AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions:</p> <p> <b>da1</b>: This version was introduced at launch in November 2017. These keys always expire after 7 days. Key expiration is managed by Amazon DynamoDB TTL. The keys ceased to be valid after February 21, 2018 and should not be used after that date.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>UpdateApiKey</code> is not available for this key version.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we will delete these keys from the table after February 21, 2018.</p> </li> </ul> <p> <b>da2</b>: This version was introduced in February 2018 when AppSync added support to extend key expiration.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in seconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds.</p> </li> <li> <p> <code>UpdateApiKey</code> returns the expiration time in seconds and accepts a user-provided expiration time in seconds. Key expiration can only be updated while the key has not expired.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in Amazon DynamoDB as seconds.</p> </li> </ul>"
    },
    "ApiKeyLimitExceededException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "documentation":"<p>The API key exceeded a limit. Try your request again.</p>",
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "ApiKeyValidityOutOfBoundsException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "documentation":"<p>The API key expiration must be set to a value between 1 and 365 days from creation (for <code>CreateApiKey</code>) or from update (for <code>UpdateApiKey</code>).</p>",
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "ApiKeys":{
      "type":"list",
      "member":{"shape":"ApiKey"}
    },
    "ApiLimitExceededException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "documentation":"<p>The GraphQL API exceeded a limit. Try your request again.</p>",
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "AuthenticationType":{
      "type":"string",
      "enum":[
        "API_KEY",
        "AWS_IAM",
        "AMAZON_COGNITO_USER_POOLS",
        "OPENID_CONNECT"
      ]
    },
    "AuthorizationConfig":{
      "type":"structure",
      "required":["authorizationType"],
      "members":{
        "authorizationType":{
          "shape":"AuthorizationType",
          "documentation":"<p>The authorization type required by the HTTP endpoint.</p> <ul> <li> <p> <